// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: storage/v1beta1/storage.proto

package storagev1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	openfgav1 "github.com/openfga/api/proto/openfga/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = openfgav1.ConsistencyPreference(0)
)

// Validate checks the field values on ReadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReadRequestMultiError, or
// nil if none found.
func (m *ReadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadRequestMultiError(errors)
	}

	return nil
}

// ReadRequestMultiError is an error wrapping multiple validation errors
// returned by ReadRequest.ValidateAll() if the designated constraints aren't met.
type ReadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadRequestMultiError) AllErrors() []error { return m }

// ReadRequestValidationError is the validation error returned by
// ReadRequest.Validate if the designated constraints aren't met.
type ReadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadRequestValidationError) ErrorName() string { return "ReadRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadRequestValidationError{}

// Validate checks the field values on ReadResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReadResponseMultiError, or
// nil if none found.
func (m *ReadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTuple()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadResponseValidationError{
					field:  "Tuple",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadResponseValidationError{
					field:  "Tuple",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTuple()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadResponseValidationError{
				field:  "Tuple",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadResponseMultiError(errors)
	}

	return nil
}

// ReadResponseMultiError is an error wrapping multiple validation errors
// returned by ReadResponse.ValidateAll() if the designated constraints aren't met.
type ReadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadResponseMultiError) AllErrors() []error { return m }

// ReadResponseValidationError is the validation error returned by
// ReadResponse.Validate if the designated constraints aren't met.
type ReadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadResponseValidationError) ErrorName() string { return "ReadResponseValidationError" }

// Error satisfies the builtin error interface
func (e ReadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadResponseValidationError{}

// Validate checks the field values on ReadPageRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadPageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadPageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadPageRequestMultiError, or nil if none found.
func (m *ReadPageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadPageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadPageRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadPageRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadPageRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadPageRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadPageRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadPageRequestValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadPageRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadPageRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadPageRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadPageRequestMultiError(errors)
	}

	return nil
}

// ReadPageRequestMultiError is an error wrapping multiple validation errors
// returned by ReadPageRequest.ValidateAll() if the designated constraints
// aren't met.
type ReadPageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadPageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadPageRequestMultiError) AllErrors() []error { return m }

// ReadPageRequestValidationError is the validation error returned by
// ReadPageRequest.Validate if the designated constraints aren't met.
type ReadPageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadPageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadPageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadPageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadPageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadPageRequestValidationError) ErrorName() string { return "ReadPageRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReadPageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadPageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadPageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadPageRequestValidationError{}

// Validate checks the field values on ReadPageResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadPageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadPageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadPageResponseMultiError, or nil if none found.
func (m *ReadPageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadPageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTuples() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadPageResponseValidationError{
						field:  fmt.Sprintf("Tuples[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadPageResponseValidationError{
						field:  fmt.Sprintf("Tuples[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadPageResponseValidationError{
					field:  fmt.Sprintf("Tuples[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ContinuationToken

	if len(errors) > 0 {
		return ReadPageResponseMultiError(errors)
	}

	return nil
}

// ReadPageResponseMultiError is an error wrapping multiple validation errors
// returned by ReadPageResponse.ValidateAll() if the designated constraints
// aren't met.
type ReadPageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadPageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadPageResponseMultiError) AllErrors() []error { return m }

// ReadPageResponseValidationError is the validation error returned by
// ReadPageResponse.Validate if the designated constraints aren't met.
type ReadPageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadPageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadPageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadPageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadPageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadPageResponseValidationError) ErrorName() string { return "ReadPageResponseValidationError" }

// Error satisfies the builtin error interface
func (e ReadPageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadPageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadPageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadPageResponseValidationError{}

// Validate checks the field values on ReadUserTupleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadUserTupleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadUserTupleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadUserTupleRequestMultiError, or nil if none found.
func (m *ReadUserTupleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadUserTupleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadUserTupleRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadUserTupleRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadUserTupleRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadUserTupleRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadUserTupleRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadUserTupleRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadUserTupleRequestMultiError(errors)
	}

	return nil
}

// ReadUserTupleRequestMultiError is an error wrapping multiple validation
// errors returned by ReadUserTupleRequest.ValidateAll() if the designated
// constraints aren't met.
type ReadUserTupleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadUserTupleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadUserTupleRequestMultiError) AllErrors() []error { return m }

// ReadUserTupleRequestValidationError is the validation error returned by
// ReadUserTupleRequest.Validate if the designated constraints aren't met.
type ReadUserTupleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadUserTupleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadUserTupleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadUserTupleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadUserTupleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadUserTupleRequestValidationError) ErrorName() string {
	return "ReadUserTupleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadUserTupleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadUserTupleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadUserTupleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadUserTupleRequestValidationError{}

// Validate checks the field values on ReadUsersetTuplesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadUsersetTuplesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadUsersetTuplesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadUsersetTuplesRequestMultiError, or nil if none found.
func (m *ReadUsersetTuplesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadUsersetTuplesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadUsersetTuplesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadUsersetTuplesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadUsersetTuplesRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadUsersetTuplesRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadUsersetTuplesRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadUsersetTuplesRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadUsersetTuplesRequestMultiError(errors)
	}

	return nil
}

// ReadUsersetTuplesRequestMultiError is an error wrapping multiple validation
// errors returned by ReadUsersetTuplesRequest.ValidateAll() if the designated
// constraints aren't met.
type ReadUsersetTuplesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadUsersetTuplesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadUsersetTuplesRequestMultiError) AllErrors() []error { return m }

// ReadUsersetTuplesRequestValidationError is the validation error returned by
// ReadUsersetTuplesRequest.Validate if the designated constraints aren't met.
type ReadUsersetTuplesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadUsersetTuplesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadUsersetTuplesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadUsersetTuplesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadUsersetTuplesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadUsersetTuplesRequestValidationError) ErrorName() string {
	return "ReadUsersetTuplesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadUsersetTuplesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadUsersetTuplesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadUsersetTuplesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadUsersetTuplesRequestValidationError{}

// Validate checks the field values on ReadStartingWithUserRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadStartingWithUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadStartingWithUserRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadStartingWithUserRequestMultiError, or nil if none found.
func (m *ReadStartingWithUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadStartingWithUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadStartingWithUserRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadStartingWithUserRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadStartingWithUserRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadStartingWithUserRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadStartingWithUserRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadStartingWithUserRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WithResultsSortedAscending

	if len(errors) > 0 {
		return ReadStartingWithUserRequestMultiError(errors)
	}

	return nil
}

// ReadStartingWithUserRequestMultiError is an error wrapping multiple
// validation errors returned by ReadStartingWithUserRequest.ValidateAll() if
// the designated constraints aren't met.
type ReadStartingWithUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadStartingWithUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadStartingWithUserRequestMultiError) AllErrors() []error { return m }

// ReadStartingWithUserRequestValidationError is the validation error returned
// by ReadStartingWithUserRequest.Validate if the designated constraints
// aren't met.
type ReadStartingWithUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadStartingWithUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadStartingWithUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadStartingWithUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadStartingWithUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadStartingWithUserRequestValidationError) ErrorName() string {
	return "ReadStartingWithUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadStartingWithUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadStartingWithUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadStartingWithUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadStartingWithUserRequestValidationError{}

// Validate checks the field values on WriteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WriteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WriteRequestMultiError, or
// nil if none found.
func (m *WriteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	for idx, item := range m.GetDeletes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WriteRequestValidationError{
						field:  fmt.Sprintf("Deletes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WriteRequestValidationError{
						field:  fmt.Sprintf("Deletes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WriteRequestValidationError{
					field:  fmt.Sprintf("Deletes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetWrites() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WriteRequestValidationError{
						field:  fmt.Sprintf("Writes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WriteRequestValidationError{
						field:  fmt.Sprintf("Writes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WriteRequestValidationError{
					field:  fmt.Sprintf("Writes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WriteRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WriteRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WriteRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WriteRequestMultiError(errors)
	}

	return nil
}

// WriteRequestMultiError is an error wrapping multiple validation errors
// returned by WriteRequest.ValidateAll() if the designated constraints aren't met.
type WriteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteRequestMultiError) AllErrors() []error { return m }

// WriteRequestValidationError is the validation error returned by
// WriteRequest.Validate if the designated constraints aren't met.
type WriteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteRequestValidationError) ErrorName() string { return "WriteRequestValidationError" }

// Error satisfies the builtin error interface
func (e WriteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteRequestValidationError{}

// Validate checks the field values on WriteResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WriteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WriteResponseMultiError, or
// nil if none found.
func (m *WriteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return WriteResponseMultiError(errors)
	}

	return nil
}

// WriteResponseMultiError is an error wrapping multiple validation errors
// returned by WriteResponse.ValidateAll() if the designated constraints
// aren't met.
type WriteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteResponseMultiError) AllErrors() []error { return m }

// WriteResponseValidationError is the validation error returned by
// WriteResponse.Validate if the designated constraints aren't met.
type WriteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteResponseValidationError) ErrorName() string { return "WriteResponseValidationError" }

// Error satisfies the builtin error interface
func (e WriteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteResponseValidationError{}

// Validate checks the field values on ReadAuthorizationModelRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadAuthorizationModelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadAuthorizationModelRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReadAuthorizationModelRequestMultiError, or nil if none found.
func (m *ReadAuthorizationModelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadAuthorizationModelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	// no validation rules for Id

	if len(errors) > 0 {
		return ReadAuthorizationModelRequestMultiError(errors)
	}

	return nil
}

// ReadAuthorizationModelRequestMultiError is an error wrapping multiple
// validation errors returned by ReadAuthorizationModelRequest.ValidateAll()
// if the designated constraints aren't met.
type ReadAuthorizationModelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadAuthorizationModelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadAuthorizationModelRequestMultiError) AllErrors() []error { return m }

// ReadAuthorizationModelRequestValidationError is the validation error
// returned by ReadAuthorizationModelRequest.Validate if the designated
// constraints aren't met.
type ReadAuthorizationModelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadAuthorizationModelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadAuthorizationModelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadAuthorizationModelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadAuthorizationModelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadAuthorizationModelRequestValidationError) ErrorName() string {
	return "ReadAuthorizationModelRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadAuthorizationModelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadAuthorizationModelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadAuthorizationModelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadAuthorizationModelRequestValidationError{}

// Validate checks the field values on ReadAuthorizationModelResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadAuthorizationModelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadAuthorizationModelResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReadAuthorizationModelResponseMultiError, or nil if none found.
func (m *ReadAuthorizationModelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadAuthorizationModelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetModel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadAuthorizationModelResponseValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadAuthorizationModelResponseValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadAuthorizationModelResponseValidationError{
				field:  "Model",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadAuthorizationModelResponseMultiError(errors)
	}

	return nil
}

// ReadAuthorizationModelResponseMultiError is an error wrapping multiple
// validation errors returned by ReadAuthorizationModelResponse.ValidateAll()
// if the designated constraints aren't met.
type ReadAuthorizationModelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadAuthorizationModelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadAuthorizationModelResponseMultiError) AllErrors() []error { return m }

// ReadAuthorizationModelResponseValidationError is the validation error
// returned by ReadAuthorizationModelResponse.Validate if the designated
// constraints aren't met.
type ReadAuthorizationModelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadAuthorizationModelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadAuthorizationModelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadAuthorizationModelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadAuthorizationModelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadAuthorizationModelResponseValidationError) ErrorName() string {
	return "ReadAuthorizationModelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadAuthorizationModelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadAuthorizationModelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadAuthorizationModelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadAuthorizationModelResponseValidationError{}

// Validate checks the field values on ReadAuthorizationModelsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadAuthorizationModelsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadAuthorizationModelsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReadAuthorizationModelsRequestMultiError, or nil if none found.
func (m *ReadAuthorizationModelsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadAuthorizationModelsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadAuthorizationModelsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadAuthorizationModelsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadAuthorizationModelsRequestValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadAuthorizationModelsRequestMultiError(errors)
	}

	return nil
}

// ReadAuthorizationModelsRequestMultiError is an error wrapping multiple
// validation errors returned by ReadAuthorizationModelsRequest.ValidateAll()
// if the designated constraints aren't met.
type ReadAuthorizationModelsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadAuthorizationModelsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadAuthorizationModelsRequestMultiError) AllErrors() []error { return m }

// ReadAuthorizationModelsRequestValidationError is the validation error
// returned by ReadAuthorizationModelsRequest.Validate if the designated
// constraints aren't met.
type ReadAuthorizationModelsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadAuthorizationModelsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadAuthorizationModelsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadAuthorizationModelsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadAuthorizationModelsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadAuthorizationModelsRequestValidationError) ErrorName() string {
	return "ReadAuthorizationModelsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadAuthorizationModelsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadAuthorizationModelsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadAuthorizationModelsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadAuthorizationModelsRequestValidationError{}

// Validate checks the field values on ReadAuthorizationModelsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadAuthorizationModelsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadAuthorizationModelsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReadAuthorizationModelsResponseMultiError, or nil if none found.
func (m *ReadAuthorizationModelsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadAuthorizationModelsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetModels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadAuthorizationModelsResponseValidationError{
						field:  fmt.Sprintf("Models[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadAuthorizationModelsResponseValidationError{
						field:  fmt.Sprintf("Models[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadAuthorizationModelsResponseValidationError{
					field:  fmt.Sprintf("Models[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ContinuationToken

	if len(errors) > 0 {
		return ReadAuthorizationModelsResponseMultiError(errors)
	}

	return nil
}

// ReadAuthorizationModelsResponseMultiError is an error wrapping multiple
// validation errors returned by ReadAuthorizationModelsResponse.ValidateAll()
// if the designated constraints aren't met.
type ReadAuthorizationModelsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadAuthorizationModelsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadAuthorizationModelsResponseMultiError) AllErrors() []error { return m }

// ReadAuthorizationModelsResponseValidationError is the validation error
// returned by ReadAuthorizationModelsResponse.Validate if the designated
// constraints aren't met.
type ReadAuthorizationModelsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadAuthorizationModelsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadAuthorizationModelsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadAuthorizationModelsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadAuthorizationModelsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadAuthorizationModelsResponseValidationError) ErrorName() string {
	return "ReadAuthorizationModelsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadAuthorizationModelsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadAuthorizationModelsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadAuthorizationModelsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadAuthorizationModelsResponseValidationError{}

// Validate checks the field values on FindLatestAuthorizationModelRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *FindLatestAuthorizationModelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FindLatestAuthorizationModelRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// FindLatestAuthorizationModelRequestMultiError, or nil if none found.
func (m *FindLatestAuthorizationModelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FindLatestAuthorizationModelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if len(errors) > 0 {
		return FindLatestAuthorizationModelRequestMultiError(errors)
	}

	return nil
}

// FindLatestAuthorizationModelRequestMultiError is an error wrapping multiple
// validation errors returned by
// FindLatestAuthorizationModelRequest.ValidateAll() if the designated
// constraints aren't met.
type FindLatestAuthorizationModelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FindLatestAuthorizationModelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FindLatestAuthorizationModelRequestMultiError) AllErrors() []error { return m }

// FindLatestAuthorizationModelRequestValidationError is the validation error
// returned by FindLatestAuthorizationModelRequest.Validate if the designated
// constraints aren't met.
type FindLatestAuthorizationModelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FindLatestAuthorizationModelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FindLatestAuthorizationModelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FindLatestAuthorizationModelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FindLatestAuthorizationModelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FindLatestAuthorizationModelRequestValidationError) ErrorName() string {
	return "FindLatestAuthorizationModelRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FindLatestAuthorizationModelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFindLatestAuthorizationModelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FindLatestAuthorizationModelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FindLatestAuthorizationModelRequestValidationError{}

// Validate checks the field values on FindLatestAuthorizationModelResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *FindLatestAuthorizationModelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FindLatestAuthorizationModelResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// FindLatestAuthorizationModelResponseMultiError, or nil if none found.
func (m *FindLatestAuthorizationModelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FindLatestAuthorizationModelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetModel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FindLatestAuthorizationModelResponseValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FindLatestAuthorizationModelResponseValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FindLatestAuthorizationModelResponseValidationError{
				field:  "Model",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FindLatestAuthorizationModelResponseMultiError(errors)
	}

	return nil
}

// FindLatestAuthorizationModelResponseMultiError is an error wrapping multiple
// validation errors returned by
// FindLatestAuthorizationModelResponse.ValidateAll() if the designated
// constraints aren't met.
type FindLatestAuthorizationModelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FindLatestAuthorizationModelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FindLatestAuthorizationModelResponseMultiError) AllErrors() []error { return m }

// FindLatestAuthorizationModelResponseValidationError is the validation error
// returned by FindLatestAuthorizationModelResponse.Validate if the designated
// constraints aren't met.
type FindLatestAuthorizationModelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FindLatestAuthorizationModelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FindLatestAuthorizationModelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FindLatestAuthorizationModelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FindLatestAuthorizationModelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FindLatestAuthorizationModelResponseValidationError) ErrorName() string {
	return "FindLatestAuthorizationModelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FindLatestAuthorizationModelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFindLatestAuthorizationModelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FindLatestAuthorizationModelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FindLatestAuthorizationModelResponseValidationError{}

// Validate checks the field values on WriteAuthorizationModelRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WriteAuthorizationModelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteAuthorizationModelRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// WriteAuthorizationModelRequestMultiError, or nil if none found.
func (m *WriteAuthorizationModelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteAuthorizationModelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if all {
		switch v := interface{}(m.GetModel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WriteAuthorizationModelRequestValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WriteAuthorizationModelRequestValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WriteAuthorizationModelRequestValidationError{
				field:  "Model",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WriteAuthorizationModelRequestMultiError(errors)
	}

	return nil
}

// WriteAuthorizationModelRequestMultiError is an error wrapping multiple
// validation errors returned by WriteAuthorizationModelRequest.ValidateAll()
// if the designated constraints aren't met.
type WriteAuthorizationModelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteAuthorizationModelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteAuthorizationModelRequestMultiError) AllErrors() []error { return m }

// WriteAuthorizationModelRequestValidationError is the validation error
// returned by WriteAuthorizationModelRequest.Validate if the designated
// constraints aren't met.
type WriteAuthorizationModelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteAuthorizationModelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteAuthorizationModelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteAuthorizationModelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteAuthorizationModelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteAuthorizationModelRequestValidationError) ErrorName() string {
	return "WriteAuthorizationModelRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WriteAuthorizationModelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteAuthorizationModelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteAuthorizationModelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteAuthorizationModelRequestValidationError{}

// Validate checks the field values on WriteAuthorizationModelResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WriteAuthorizationModelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteAuthorizationModelResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// WriteAuthorizationModelResponseMultiError, or nil if none found.
func (m *WriteAuthorizationModelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteAuthorizationModelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return WriteAuthorizationModelResponseMultiError(errors)
	}

	return nil
}

// WriteAuthorizationModelResponseMultiError is an error wrapping multiple
// validation errors returned by WriteAuthorizationModelResponse.ValidateAll()
// if the designated constraints aren't met.
type WriteAuthorizationModelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteAuthorizationModelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteAuthorizationModelResponseMultiError) AllErrors() []error { return m }

// WriteAuthorizationModelResponseValidationError is the validation error
// returned by WriteAuthorizationModelResponse.Validate if the designated
// constraints aren't met.
type WriteAuthorizationModelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteAuthorizationModelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteAuthorizationModelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteAuthorizationModelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteAuthorizationModelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteAuthorizationModelResponseValidationError) ErrorName() string {
	return "WriteAuthorizationModelResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WriteAuthorizationModelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteAuthorizationModelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteAuthorizationModelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteAuthorizationModelResponseValidationError{}

// Validate checks the field values on CreateStoreRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateStoreRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStoreRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateStoreRequestMultiError, or nil if none found.
func (m *CreateStoreRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStoreRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStoreRequestValidationError{
					field:  "Store",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStoreRequestValidationError{
					field:  "Store",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStoreRequestValidationError{
				field:  "Store",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateStoreRequestMultiError(errors)
	}

	return nil
}

// CreateStoreRequestMultiError is an error wrapping multiple validation errors
// returned by CreateStoreRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateStoreRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStoreRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStoreRequestMultiError) AllErrors() []error { return m }

// CreateStoreRequestValidationError is the validation error returned by
// CreateStoreRequest.Validate if the designated constraints aren't met.
type CreateStoreRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStoreRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStoreRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStoreRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStoreRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStoreRequestValidationError) ErrorName() string {
	return "CreateStoreRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStoreRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStoreRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStoreRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStoreRequestValidationError{}

// Validate checks the field values on CreateStoreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateStoreResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStoreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateStoreResponseMultiError, or nil if none found.
func (m *CreateStoreResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStoreResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStoreResponseValidationError{
					field:  "Store",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStoreResponseValidationError{
					field:  "Store",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStoreResponseValidationError{
				field:  "Store",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateStoreResponseMultiError(errors)
	}

	return nil
}

// CreateStoreResponseMultiError is an error wrapping multiple validation
// errors returned by CreateStoreResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateStoreResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStoreResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStoreResponseMultiError) AllErrors() []error { return m }

// CreateStoreResponseValidationError is the validation error returned by
// CreateStoreResponse.Validate if the designated constraints aren't met.
type CreateStoreResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStoreResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStoreResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStoreResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStoreResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStoreResponseValidationError) ErrorName() string {
	return "CreateStoreResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStoreResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStoreResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStoreResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStoreResponseValidationError{}

// Validate checks the field values on DeleteStoreRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteStoreRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteStoreRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteStoreRequestMultiError, or nil if none found.
func (m *DeleteStoreRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteStoreRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteStoreRequestMultiError(errors)
	}

	return nil
}

// DeleteStoreRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteStoreRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteStoreRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteStoreRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteStoreRequestMultiError) AllErrors() []error { return m }

// DeleteStoreRequestValidationError is the validation error returned by
// DeleteStoreRequest.Validate if the designated constraints aren't met.
type DeleteStoreRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteStoreRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteStoreRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteStoreRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteStoreRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteStoreRequestValidationError) ErrorName() string {
	return "DeleteStoreRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteStoreRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteStoreRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteStoreRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteStoreRequestValidationError{}

// Validate checks the field values on DeleteStoreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteStoreResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteStoreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteStoreResponseMultiError, or nil if none found.
func (m *DeleteStoreResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteStoreResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteStoreResponseMultiError(errors)
	}

	return nil
}

// DeleteStoreResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteStoreResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteStoreResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteStoreResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteStoreResponseMultiError) AllErrors() []error { return m }

// DeleteStoreResponseValidationError is the validation error returned by
// DeleteStoreResponse.Validate if the designated constraints aren't met.
type DeleteStoreResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteStoreResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteStoreResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteStoreResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteStoreResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteStoreResponseValidationError) ErrorName() string {
	return "DeleteStoreResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteStoreResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteStoreResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteStoreResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteStoreResponseValidationError{}

// Validate checks the field values on GetStoreRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetStoreRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStoreRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStoreRequestMultiError, or nil if none found.
func (m *GetStoreRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStoreRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetStoreRequestMultiError(errors)
	}

	return nil
}

// GetStoreRequestMultiError is an error wrapping multiple validation errors
// returned by GetStoreRequest.ValidateAll() if the designated constraints
// aren't met.
type GetStoreRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStoreRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStoreRequestMultiError) AllErrors() []error { return m }

// GetStoreRequestValidationError is the validation error returned by
// GetStoreRequest.Validate if the designated constraints aren't met.
type GetStoreRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStoreRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStoreRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStoreRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStoreRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStoreRequestValidationError) ErrorName() string { return "GetStoreRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetStoreRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStoreRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStoreRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStoreRequestValidationError{}

// Validate checks the field values on GetStoreResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetStoreResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStoreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStoreResponseMultiError, or nil if none found.
func (m *GetStoreResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStoreResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetStoreResponseValidationError{
					field:  "Store",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetStoreResponseValidationError{
					field:  "Store",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetStoreResponseValidationError{
				field:  "Store",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetStoreResponseMultiError(errors)
	}

	return nil
}

// GetStoreResponseMultiError is an error wrapping multiple validation errors
// returned by GetStoreResponse.ValidateAll() if the designated constraints
// aren't met.
type GetStoreResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStoreResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStoreResponseMultiError) AllErrors() []error { return m }

// GetStoreResponseValidationError is the validation error returned by
// GetStoreResponse.Validate if the designated constraints aren't met.
type GetStoreResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStoreResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStoreResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStoreResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStoreResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStoreResponseValidationError) ErrorName() string { return "GetStoreResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetStoreResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStoreResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStoreResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStoreResponseValidationError{}

// Validate checks the field values on ListStoresRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListStoresRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListStoresRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListStoresRequestMultiError, or nil if none found.
func (m *ListStoresRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListStoresRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListStoresRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListStoresRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListStoresRequestValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListStoresRequestMultiError(errors)
	}

	return nil
}

// ListStoresRequestMultiError is an error wrapping multiple validation errors
// returned by ListStoresRequest.ValidateAll() if the designated constraints
// aren't met.
type ListStoresRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStoresRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStoresRequestMultiError) AllErrors() []error { return m }

// ListStoresRequestValidationError is the validation error returned by
// ListStoresRequest.Validate if the designated constraints aren't met.
type ListStoresRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStoresRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStoresRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStoresRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStoresRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStoresRequestValidationError) ErrorName() string {
	return "ListStoresRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListStoresRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStoresRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStoresRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStoresRequestValidationError{}

// Validate checks the field values on ListStoresResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListStoresResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListStoresResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListStoresResponseMultiError, or nil if none found.
func (m *ListStoresResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListStoresResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStores() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListStoresResponseValidationError{
						field:  fmt.Sprintf("Stores[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListStoresResponseValidationError{
						field:  fmt.Sprintf("Stores[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListStoresResponseValidationError{
					field:  fmt.Sprintf("Stores[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ContinuationToken

	if len(errors) > 0 {
		return ListStoresResponseMultiError(errors)
	}

	return nil
}

// ListStoresResponseMultiError is an error wrapping multiple validation errors
// returned by ListStoresResponse.ValidateAll() if the designated constraints
// aren't met.
type ListStoresResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStoresResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStoresResponseMultiError) AllErrors() []error { return m }

// ListStoresResponseValidationError is the validation error returned by
// ListStoresResponse.Validate if the designated constraints aren't met.
type ListStoresResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStoresResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStoresResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStoresResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStoresResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStoresResponseValidationError) ErrorName() string {
	return "ListStoresResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListStoresResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStoresResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStoresResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStoresResponseValidationError{}

// Validate checks the field values on WriteAssertionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WriteAssertionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteAssertionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WriteAssertionsRequestMultiError, or nil if none found.
func (m *WriteAssertionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteAssertionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	// no validation rules for ModelId

	for idx, item := range m.GetAssertions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WriteAssertionsRequestValidationError{
						field:  fmt.Sprintf("Assertions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WriteAssertionsRequestValidationError{
						field:  fmt.Sprintf("Assertions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WriteAssertionsRequestValidationError{
					field:  fmt.Sprintf("Assertions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WriteAssertionsRequestMultiError(errors)
	}

	return nil
}

// WriteAssertionsRequestMultiError is an error wrapping multiple validation
// errors returned by WriteAssertionsRequest.ValidateAll() if the designated
// constraints aren't met.
type WriteAssertionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteAssertionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteAssertionsRequestMultiError) AllErrors() []error { return m }

// WriteAssertionsRequestValidationError is the validation error returned by
// WriteAssertionsRequest.Validate if the designated constraints aren't met.
type WriteAssertionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteAssertionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteAssertionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteAssertionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteAssertionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteAssertionsRequestValidationError) ErrorName() string {
	return "WriteAssertionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WriteAssertionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteAssertionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteAssertionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteAssertionsRequestValidationError{}

// Validate checks the field values on WriteAssertionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WriteAssertionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteAssertionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WriteAssertionsResponseMultiError, or nil if none found.
func (m *WriteAssertionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteAssertionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return WriteAssertionsResponseMultiError(errors)
	}

	return nil
}

// WriteAssertionsResponseMultiError is an error wrapping multiple validation
// errors returned by WriteAssertionsResponse.ValidateAll() if the designated
// constraints aren't met.
type WriteAssertionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteAssertionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteAssertionsResponseMultiError) AllErrors() []error { return m }

// WriteAssertionsResponseValidationError is the validation error returned by
// WriteAssertionsResponse.Validate if the designated constraints aren't met.
type WriteAssertionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteAssertionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteAssertionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteAssertionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteAssertionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteAssertionsResponseValidationError) ErrorName() string {
	return "WriteAssertionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WriteAssertionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteAssertionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteAssertionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteAssertionsResponseValidationError{}

// Validate checks the field values on ReadAssertionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadAssertionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadAssertionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadAssertionsRequestMultiError, or nil if none found.
func (m *ReadAssertionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadAssertionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	// no validation rules for ModelId

	if len(errors) > 0 {
		return ReadAssertionsRequestMultiError(errors)
	}

	return nil
}

// ReadAssertionsRequestMultiError is an error wrapping multiple validation
// errors returned by ReadAssertionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ReadAssertionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadAssertionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadAssertionsRequestMultiError) AllErrors() []error { return m }

// ReadAssertionsRequestValidationError is the validation error returned by
// ReadAssertionsRequest.Validate if the designated constraints aren't met.
type ReadAssertionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadAssertionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadAssertionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadAssertionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadAssertionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadAssertionsRequestValidationError) ErrorName() string {
	return "ReadAssertionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadAssertionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadAssertionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadAssertionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadAssertionsRequestValidationError{}

// Validate checks the field values on ReadAssertionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadAssertionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadAssertionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadAssertionsResponseMultiError, or nil if none found.
func (m *ReadAssertionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadAssertionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAssertions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadAssertionsResponseValidationError{
						field:  fmt.Sprintf("Assertions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadAssertionsResponseValidationError{
						field:  fmt.Sprintf("Assertions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadAssertionsResponseValidationError{
					field:  fmt.Sprintf("Assertions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReadAssertionsResponseMultiError(errors)
	}

	return nil
}

// ReadAssertionsResponseMultiError is an error wrapping multiple validation
// errors returned by ReadAssertionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ReadAssertionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadAssertionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadAssertionsResponseMultiError) AllErrors() []error { return m }

// ReadAssertionsResponseValidationError is the validation error returned by
// ReadAssertionsResponse.Validate if the designated constraints aren't met.
type ReadAssertionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadAssertionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadAssertionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadAssertionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadAssertionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadAssertionsResponseValidationError) ErrorName() string {
	return "ReadAssertionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadAssertionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadAssertionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadAssertionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadAssertionsResponseValidationError{}

// Validate checks the field values on ReadChangesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadChangesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadChangesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadChangesRequestMultiError, or nil if none found.
func (m *ReadChangesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadChangesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Store

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadChangesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadChangesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadChangesRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadChangesRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadChangesRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadChangesRequestValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SortDesc

	if len(errors) > 0 {
		return ReadChangesRequestMultiError(errors)
	}

	return nil
}

// ReadChangesRequestMultiError is an error wrapping multiple validation errors
// returned by ReadChangesRequest.ValidateAll() if the designated constraints
// aren't met.
type ReadChangesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadChangesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadChangesRequestMultiError) AllErrors() []error { return m }

// ReadChangesRequestValidationError is the validation error returned by
// ReadChangesRequest.Validate if the designated constraints aren't met.
type ReadChangesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadChangesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadChangesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadChangesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadChangesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadChangesRequestValidationError) ErrorName() string {
	return "ReadChangesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadChangesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadChangesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadChangesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadChangesRequestValidationError{}

// Validate checks the field values on ReadChangesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadChangesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadChangesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadChangesResponseMultiError, or nil if none found.
func (m *ReadChangesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadChangesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetChanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadChangesResponseValidationError{
						field:  fmt.Sprintf("Changes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadChangesResponseValidationError{
						field:  fmt.Sprintf("Changes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadChangesResponseValidationError{
					field:  fmt.Sprintf("Changes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ContinuationToken

	if len(errors) > 0 {
		return ReadChangesResponseMultiError(errors)
	}

	return nil
}

// ReadChangesResponseMultiError is an error wrapping multiple validation
// errors returned by ReadChangesResponse.ValidateAll() if the designated
// constraints aren't met.
type ReadChangesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadChangesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadChangesResponseMultiError) AllErrors() []error { return m }

// ReadChangesResponseValidationError is the validation error returned by
// ReadChangesResponse.Validate if the designated constraints aren't met.
type ReadChangesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadChangesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadChangesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadChangesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadChangesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadChangesResponseValidationError) ErrorName() string {
	return "ReadChangesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadChangesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadChangesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadChangesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadChangesResponseValidationError{}

// Validate checks the field values on IsReadyRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IsReadyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsReadyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IsReadyRequestMultiError,
// or nil if none found.
func (m *IsReadyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IsReadyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IsReadyRequestMultiError(errors)
	}

	return nil
}

// IsReadyRequestMultiError is an error wrapping multiple validation errors
// returned by IsReadyRequest.ValidateAll() if the designated constraints
// aren't met.
type IsReadyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsReadyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsReadyRequestMultiError) AllErrors() []error { return m }

// IsReadyRequestValidationError is the validation error returned by
// IsReadyRequest.Validate if the designated constraints aren't met.
type IsReadyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsReadyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsReadyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsReadyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsReadyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsReadyRequestValidationError) ErrorName() string { return "IsReadyRequestValidationError" }

// Error satisfies the builtin error interface
func (e IsReadyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsReadyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsReadyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsReadyRequestValidationError{}

// Validate checks the field values on IsReadyResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IsReadyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsReadyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IsReadyResponseMultiError, or nil if none found.
func (m *IsReadyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IsReadyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for IsReady

	if len(errors) > 0 {
		return IsReadyResponseMultiError(errors)
	}

	return nil
}

// IsReadyResponseMultiError is an error wrapping multiple validation errors
// returned by IsReadyResponse.ValidateAll() if the designated constraints
// aren't met.
type IsReadyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsReadyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsReadyResponseMultiError) AllErrors() []error { return m }

// IsReadyResponseValidationError is the validation error returned by
// IsReadyResponse.Validate if the designated constraints aren't met.
type IsReadyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsReadyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsReadyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsReadyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsReadyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsReadyResponseValidationError) ErrorName() string { return "IsReadyResponseValidationError" }

// Error satisfies the builtin error interface
func (e IsReadyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsReadyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsReadyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsReadyResponseValidationError{}

// Validate checks the field values on ReadFilter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReadFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReadFilterMultiError, or
// nil if none found.
func (m *ReadFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Object

	// no validation rules for Relation

	// no validation rules for User

	if len(errors) > 0 {
		return ReadFilterMultiError(errors)
	}

	return nil
}

// ReadFilterMultiError is an error wrapping multiple validation errors
// returned by ReadFilter.ValidateAll() if the designated constraints aren't met.
type ReadFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadFilterMultiError) AllErrors() []error { return m }

// ReadFilterValidationError is the validation error returned by
// ReadFilter.Validate if the designated constraints aren't met.
type ReadFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadFilterValidationError) ErrorName() string { return "ReadFilterValidationError" }

// Error satisfies the builtin error interface
func (e ReadFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadFilterValidationError{}

// Validate checks the field values on ReadUsersetTuplesFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadUsersetTuplesFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadUsersetTuplesFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadUsersetTuplesFilterMultiError, or nil if none found.
func (m *ReadUsersetTuplesFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadUsersetTuplesFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Object

	// no validation rules for Relation

	for idx, item := range m.GetAllowedUserTypeRestrictions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadUsersetTuplesFilterValidationError{
						field:  fmt.Sprintf("AllowedUserTypeRestrictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadUsersetTuplesFilterValidationError{
						field:  fmt.Sprintf("AllowedUserTypeRestrictions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadUsersetTuplesFilterValidationError{
					field:  fmt.Sprintf("AllowedUserTypeRestrictions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReadUsersetTuplesFilterMultiError(errors)
	}

	return nil
}

// ReadUsersetTuplesFilterMultiError is an error wrapping multiple validation
// errors returned by ReadUsersetTuplesFilter.ValidateAll() if the designated
// constraints aren't met.
type ReadUsersetTuplesFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadUsersetTuplesFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadUsersetTuplesFilterMultiError) AllErrors() []error { return m }

// ReadUsersetTuplesFilterValidationError is the validation error returned by
// ReadUsersetTuplesFilter.Validate if the designated constraints aren't met.
type ReadUsersetTuplesFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadUsersetTuplesFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadUsersetTuplesFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadUsersetTuplesFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadUsersetTuplesFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadUsersetTuplesFilterValidationError) ErrorName() string {
	return "ReadUsersetTuplesFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ReadUsersetTuplesFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadUsersetTuplesFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadUsersetTuplesFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadUsersetTuplesFilterValidationError{}

// Validate checks the field values on ReadStartingWithUserFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadStartingWithUserFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadStartingWithUserFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadStartingWithUserFilterMultiError, or nil if none found.
func (m *ReadStartingWithUserFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadStartingWithUserFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ObjectType

	// no validation rules for Relation

	for idx, item := range m.GetUserFilter() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadStartingWithUserFilterValidationError{
						field:  fmt.Sprintf("UserFilter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadStartingWithUserFilterValidationError{
						field:  fmt.Sprintf("UserFilter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadStartingWithUserFilterValidationError{
					field:  fmt.Sprintf("UserFilter[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReadStartingWithUserFilterMultiError(errors)
	}

	return nil
}

// ReadStartingWithUserFilterMultiError is an error wrapping multiple
// validation errors returned by ReadStartingWithUserFilter.ValidateAll() if
// the designated constraints aren't met.
type ReadStartingWithUserFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadStartingWithUserFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadStartingWithUserFilterMultiError) AllErrors() []error { return m }

// ReadStartingWithUserFilterValidationError is the validation error returned
// by ReadStartingWithUserFilter.Validate if the designated constraints aren't met.
type ReadStartingWithUserFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadStartingWithUserFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadStartingWithUserFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadStartingWithUserFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadStartingWithUserFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadStartingWithUserFilterValidationError) ErrorName() string {
	return "ReadStartingWithUserFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ReadStartingWithUserFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadStartingWithUserFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadStartingWithUserFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadStartingWithUserFilterValidationError{}

// Validate checks the field values on ReadChangesFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadChangesFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadChangesFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadChangesFilterMultiError, or nil if none found.
func (m *ReadChangesFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadChangesFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ObjectType

	// no validation rules for HorizonOffsetMs

	if len(errors) > 0 {
		return ReadChangesFilterMultiError(errors)
	}

	return nil
}

// ReadChangesFilterMultiError is an error wrapping multiple validation errors
// returned by ReadChangesFilter.ValidateAll() if the designated constraints
// aren't met.
type ReadChangesFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadChangesFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadChangesFilterMultiError) AllErrors() []error { return m }

// ReadChangesFilterValidationError is the validation error returned by
// ReadChangesFilter.Validate if the designated constraints aren't met.
type ReadChangesFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadChangesFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadChangesFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadChangesFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadChangesFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadChangesFilterValidationError) ErrorName() string {
	return "ReadChangesFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ReadChangesFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadChangesFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadChangesFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadChangesFilterValidationError{}

// Validate checks the field values on PaginationOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PaginationOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaginationOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaginationOptionsMultiError, or nil if none found.
func (m *PaginationOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *PaginationOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for From

	if len(errors) > 0 {
		return PaginationOptionsMultiError(errors)
	}

	return nil
}

// PaginationOptionsMultiError is an error wrapping multiple validation errors
// returned by PaginationOptions.ValidateAll() if the designated constraints
// aren't met.
type PaginationOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaginationOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaginationOptionsMultiError) AllErrors() []error { return m }

// PaginationOptionsValidationError is the validation error returned by
// PaginationOptions.Validate if the designated constraints aren't met.
type PaginationOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaginationOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaginationOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaginationOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaginationOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaginationOptionsValidationError) ErrorName() string {
	return "PaginationOptionsValidationError"
}

// Error satisfies the builtin error interface
func (e PaginationOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaginationOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaginationOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaginationOptionsValidationError{}

// Validate checks the field values on ConsistencyOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsistencyOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsistencyOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsistencyOptionsMultiError, or nil if none found.
func (m *ConsistencyOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsistencyOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Preference

	if len(errors) > 0 {
		return ConsistencyOptionsMultiError(errors)
	}

	return nil
}

// ConsistencyOptionsMultiError is an error wrapping multiple validation errors
// returned by ConsistencyOptions.ValidateAll() if the designated constraints
// aren't met.
type ConsistencyOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsistencyOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsistencyOptionsMultiError) AllErrors() []error { return m }

// ConsistencyOptionsValidationError is the validation error returned by
// ConsistencyOptions.Validate if the designated constraints aren't met.
type ConsistencyOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsistencyOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsistencyOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsistencyOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsistencyOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsistencyOptionsValidationError) ErrorName() string {
	return "ConsistencyOptionsValidationError"
}

// Error satisfies the builtin error interface
func (e ConsistencyOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsistencyOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsistencyOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsistencyOptionsValidationError{}

// Validate checks the field values on TupleWriteOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TupleWriteOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TupleWriteOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TupleWriteOptionsMultiError, or nil if none found.
func (m *TupleWriteOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *TupleWriteOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OnMissingDelete

	// no validation rules for OnDuplicateInsert

	if len(errors) > 0 {
		return TupleWriteOptionsMultiError(errors)
	}

	return nil
}

// TupleWriteOptionsMultiError is an error wrapping multiple validation errors
// returned by TupleWriteOptions.ValidateAll() if the designated constraints
// aren't met.
type TupleWriteOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TupleWriteOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TupleWriteOptionsMultiError) AllErrors() []error { return m }

// TupleWriteOptionsValidationError is the validation error returned by
// TupleWriteOptions.Validate if the designated constraints aren't met.
type TupleWriteOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TupleWriteOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TupleWriteOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TupleWriteOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TupleWriteOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TupleWriteOptionsValidationError) ErrorName() string {
	return "TupleWriteOptionsValidationError"
}

// Error satisfies the builtin error interface
func (e TupleWriteOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTupleWriteOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TupleWriteOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TupleWriteOptionsValidationError{}
